(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{544:function(v,t,e){"use strict";e.r(t);var r=e(7),a=Object(r.a)({},(function(){var v=this,t=v.$createElement,e=v._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"vue-的两个核心是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-的两个核心是什么"}},[v._v("#")]),v._v(" vue 的两个核心是什么?")]),v._v(" "),e("ul",[e("li",[v._v("数据驱动")]),v._v(" "),e("li",[v._v("组件化思想")])]),v._v(" "),e("h2",{attrs:{id:"vue的优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue的优点"}},[v._v("#")]),v._v(" vue的优点?")]),v._v(" "),e("p",[v._v("轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb"),e("br"),v._v("\n简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习"),e("br"),v._v("\n双向数据绑定"),e("br"),v._v("\n组件化"),e("br"),v._v("\n视图，数据，结构分离"),e("br"),v._v("\n运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势")]),v._v(" "),e("h2",{attrs:{id:"vue生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[v._v("#")]),v._v(" vue生命周期")]),v._v(" "),e("p",[v._v("生命周期：总共分为8个阶段，"),e("strong",[e("em",[v._v("创建前/后")]),v._v("，载入前/后，更新前/后，销毁前/后")]),e("br"),v._v(" "),e("strong",[v._v("beforeCreate")]),v._v(" 阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。"),e("br"),v._v(" "),e("strong",[v._v("created")]),v._v(" 阶段，已经有了数据对象data，但$el还没有。"),e("br"),v._v(" "),e("strong",[v._v("beforeMount")]),v._v(" 阶段，vue实例的$el和数据对象data都已经初始化，但还是虚拟的dom节点。"),e("br"),v._v(" "),e("strong",[v._v("mounted")]),v._v(" 阶段，模板已经编译好，虚拟dom渲染成真正的dom标签，数据已经渲染到页面，Vue实例已经创建完毕。"),e("br"),v._v(" "),e("strong",[v._v("beforeUpdate")]),v._v(" 阶段当数据依赖改变时，对象data中的数据已经更改（虚拟dom已经重新渲染），但是还未开始渲染真正dom，页面中的值还是原来的。"),e("br"),v._v(" "),e("strong",[v._v("updated")]),v._v(" 阶段data中的数据更新完毕，页面已经被重新渲染。"),e("br"),v._v(" "),e("strong",[v._v("beforeDestroy")]),v._v(" 阶段实例还是可用的一般在这里做一些善后工作。（例如清除定时器、清除非指令绑定的事件等等。）。"),e("br"),v._v(" "),e("strong",[v._v("destroyed")]),v._v(" 阶段Vue实例被销毁，观察者、子组件、事件监听被清除（页面数据不会消失，只是响应式无效了）。")]),v._v(" "),e("p",[e("strong",[v._v("一般会在created和mounted阶段做网络请求和第三方插件的初始化。在destroyed阶段进行清除定时器和一些事件的解绑")])]),v._v(" "),e("h2",{attrs:{id:"vue的响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue的响应式原理"}},[v._v("#")]),v._v(" vue的响应式原理?")]),v._v(" "),e("p",[v._v("最基本的原理就是通过 "),e("strong",[v._v("Object.defineProperty()")]),v._v(" 来劫持各个属性 的 "),e("strong",[v._v("setter")]),v._v("，"),e("strong",[v._v("getter")]),v._v("，在数据变动时发布消息给订阅者，触发相应的监听回调。")]),v._v(" "),e("h2",{attrs:{id:"v-if和v-show有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-show有什么区别"}},[v._v("#")]),v._v(" v-if和v-show有什么区别?")]),v._v(" "),e("p",[v._v("v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；")]),v._v(" "),e("p",[v._v("而v-if会控制这个 DOM 节点的存在与否。当只需要一次显示或隐藏时，使用v-if更加合理。")]),v._v(" "),e("h2",{attrs:{id:"mvvm-框架设计理念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-框架设计理念"}},[v._v("#")]),v._v(" MVVM 框架设计理念?")]),v._v(" "),e("h2",{attrs:{id:"vue-的事件机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-的事件机制"}},[v._v("#")]),v._v(" Vue 的事件机制?")]),v._v(" "),e("h2",{attrs:{id:"vue-双向绑定实现原理-diff-算法的内部实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-双向绑定实现原理-diff-算法的内部实现"}},[v._v("#")]),v._v(" Vue 双向绑定实现原理,Diff 算法的内部实现?")])])}),[],!1,null,null,null);t.default=a.exports}}]);