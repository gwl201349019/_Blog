(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{543:function(a,t,s){"use strict";s.r(t);var r=s(7),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"null-和-undefined-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined-的区别"}},[a._v("#")]),a._v(" null 和 undefined 的区别?")]),a._v(" "),s("h2",{attrs:{id:"至少可以说出三种判断-javascript-数据类型的方式-以及他们的优缺点-如何准确的判断数组类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#至少可以说出三种判断-javascript-数据类型的方式-以及他们的优缺点-如何准确的判断数组类型"}},[a._v("#")]),a._v(" 至少可以说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型?")]),a._v(" "),s("h2",{attrs:{id:"可以描述-new-一个对象的详细过程-手动实现一个-new-操作符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可以描述-new-一个对象的详细过程-手动实现一个-new-操作符"}},[a._v("#")]),a._v(" 可以描述 new 一个对象的详细过程，手动实现一个 new 操作符?")]),a._v(" "),s("h2",{attrs:{id:"理解-javascript-的作用域和作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#理解-javascript-的作用域和作用域链"}},[a._v("#")]),a._v(" 理解 JavaScript 的作用域和作用域链?")]),a._v(" "),s("h2",{attrs:{id:"this-的原理以及几种不同使用场景的取值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this-的原理以及几种不同使用场景的取值"}},[a._v("#")]),a._v(" this 的原理以及几种不同使用场景的取值?")]),a._v(" "),s("h2",{attrs:{id:"函数声明与函数表达式的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数声明与函数表达式的区别"}},[a._v("#")]),a._v(" 函数声明与函数表达式的区别?")]),a._v(" "),s("p",[a._v("在 Javscript 中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视 同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于 函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。")]),a._v(" "),s("h2",{attrs:{id:"javascript-的事件流模型都有什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的事件流模型都有什么"}},[a._v("#")]),a._v(" Javascript 的事件流模型都有什么?")]),a._v(" "),s("ul",[s("li",[a._v("事件冒泡，事件开始由最具体的元素接受，然后逐级向上传播")]),a._v(" "),s("li",[a._v("事件捕捉，事件由最不具体的节点先接收，然后逐级向下，一直到最具体的")]),a._v(" "),s("li",[a._v("DOM 事件流，三个阶段：事件捕捉=>目标阶段=>事件冒泡")])]),a._v(" "),s("h2",{attrs:{id:"谈谈你对-dom-bom-的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对-dom-bom-的理解"}},[a._v("#")]),a._v(" 谈谈你对 DOM,BOM 的理解?")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("DOM")]),a._v(" 是文档对象模型，包括了获取元素，修改样式，操作元素三方面内容，也是我们进行 最多的操作，有很多兼容性写法")]),a._v(" "),s("li",[s("strong",[a._v("BOM")]),a._v(" 是浏览器对象模型，包括浏览器的一些操作，")]),a._v(" "),s("li",[a._v("window.onload,window.open 等还有浏览器事件，监听窗口的改变 onresize,监听滚动事 件 onscroll 等")])]),a._v(" "),s("h2",{attrs:{id:"href-和-src-有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#href-和-src-有什么区别"}},[a._v("#")]),a._v(" href 和 src 有什么区别?")]),a._v(" "),s("ul",[s("li",[a._v("href 是文档之间的跳转")]),a._v(" "),s("li",[a._v("src 是资源的引用，将指定资源插入到 src 所在的位置")])]),a._v(" "),s("h2",{attrs:{id:"原型、原型链的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型、原型链的原理"}},[a._v("#")]),a._v(" 原型、原型链的原理?")]),a._v(" "),s("ul",[s("li",[a._v("原型就是每个对象都自己的原型、我们一般访问对象的 属性和方法的时候、js 会先访问对象本身的属性和方法、如果对象没有这些属性和方法就 会访问对象对应的原型 。")]),a._v(" "),s("li",[a._v("原型链子的话就是原型、原型的原型、原型的原型的原型是一个规则组成的、一般都在继承 的时候会用。")])]),a._v(" "),s("h2",{attrs:{id:"在什么情况下会遇到跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在什么情况下会遇到跨域"}},[a._v("#")]),a._v(" 在什么情况下会遇到跨域?")]),a._v(" "),s("ul",[s("li",[a._v("在协议( http )、主机名( 192.168.1.166 )、端口( :8080 )不统一的情况下会出现跨 域问题。")])]),a._v(" "),s("h2",{attrs:{id:"解释什么是-json"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解释什么是-json"}},[a._v("#")]),a._v(" 解释什么是 Json?")]),a._v(" "),s("ul",[s("li",[a._v("json 是一种轻量级的数据交换格式、主要格式是由 array 和 object 组成的、里面 的字段数据类型的话就 是 js 的一些基本类型。")])]),a._v(" "),s("h2",{attrs:{id:"解决跨域问题的方法-并说一下具体的实现方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决跨域问题的方法-并说一下具体的实现方法"}},[a._v("#")]),a._v(" 解决跨域问题的方法，并说一下具体的实现方法?")]),a._v(" "),s("ul",[s("li",[a._v("第一种：就是让后台接口文件中添加个响应头来允许指定域或所有域请求访问文件。")]),a._v(" "),s("li",[a._v("第二种：前端可以使用 "),s("strong",[a._v("JSONP")]),a._v(" 来解决( 不过后台的代码也得更改，如果问咋改的直接说不清 楚就可以 )")]),a._v(" "),s("li",[a._v("第三种：也可以使用 "),s("strong",[a._v("nginx")]),a._v(" 代理来解决、将两个域的地址都通过一个统一的地 址来转发，这样就可以避免出现跨域问题。")])]),a._v(" "),s("h2",{attrs:{id:"闭包的原理及代码和应用场景-滥用闭包造成内存泄漏-怎么处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的原理及代码和应用场景-滥用闭包造成内存泄漏-怎么处理"}},[a._v("#")]),a._v(" 闭包的原理及代码和应用场景，滥用闭包造成内存泄漏， 怎么处理?")]),a._v(" "),s("p",[a._v("函数嵌套函数、函数内部嵌套的函数可以访问外部函数的变量。 函数内部如果访问外部的变量，则外部的变量不会被垃圾回收机制回收")]),a._v(" "),s("ul",[s("li",[a._v("优点\n"),s("ul",[s("li",[a._v("保护函数内的变量安全，加强封装性")]),a._v(" "),s("li",[a._v("在内存中维持一个变量")])])]),a._v(" "),s("li",[a._v("缺点\n"),s("ul",[s("li",[a._v("闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅是因为它常驻 内寸，更重要的是对闭包使用不当会照成无用内存的产生。")]),a._v(" "),s("li",[a._v("解决方法是，在退出函数之前，将不使用的局部变量全部删除")])])]),a._v(" "),s("li",[a._v("应用场景\n"),s("ul",[s("li",[a._v("封装公共插件")]),a._v(" "),s("li",[a._v("函数外部想使用函数内部的变量是，使用闭包")]),a._v(" "),s("li",[a._v("解决 for 循环绑定事件，内部拿不到外部 i 的值")])])])]),a._v(" "),s("h2",{attrs:{id:"什么是-jsonp-是用来干什么的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-jsonp-是用来干什么的"}},[a._v("#")]),a._v(" 什么是 jsonp，是用来干什么的?")]),a._v(" "),s("ul",[s("li",[a._v("jsonp 是一种请求数据的一种方式，可用于解决主流浏览器的跨域数 据访问的问题")])])])}),[],!1,null,null,null);t.default=v.exports}}]);